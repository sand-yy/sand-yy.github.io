<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sand's site</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }
        canvas { image-rendering: pixelated; width: 100vw !important; height: 100vh !important; display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 24px; pointer-events: none; z-index: 11; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               color: white; text-align: center; display: none; background: #000; padding: 30px; border: 1px solid #0f0; z-index: 12; }
        button { background: #004400; color: #0f0; border: 1px solid #0f0; padding: 10px 20px; font-weight: bold; cursor: pointer; margin-top: 15px; }
    </style>
</head>
<body>
    <div id="crt-overlay"></div>
    <div id="ui">Score: 0</div>
    
    <div id="msg">
        <h1>err.youlost</h1>
        <button onclick="window.location.reload()">respawn</button>
    </div>

    <audio id="bgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/Air%20Waves.mp3"></audio>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const PIXEL_SCALE = 2;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.05));

        // Player
        const player = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 })
        );
        player.position.y = 0.5;
        scene.add(player);

        const pLight = new THREE.PointLight(0x00ff00, 35, 12);
        scene.add(pLight);

        // Floor - Matte Lambert (No reflectance)
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 2000),
            new THREE.MeshLambertMaterial({ color: 0x080808 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        camera.position.set(0, 4, 8);
        camera.lookAt(0, 1, 0);

        // Music Trigger Logic
        const audio = document.getElementById('bgm');
        let musicStarted = false;
        function startMusic() {
            if (!musicStarted) {
                audio.play().catch(e => console.log("Audio waiting for interaction"));
                musicStarted = true;
            }
        }

        // Game State
        let score = 0, obstacles = [], particles = [], speed = 0.35, gameOver = false, isJumping = false, velocityY = 0;
        const gravity = -0.016, jumpPower = 0.3, friction = 0.96;

        const keys = { Left: false, Right: false };
        window.addEventListener('keydown', (e) => {
            startMusic();
            if (e.key === 'ArrowLeft') keys.Left = true;
            if (e.key === 'ArrowRight') keys.Right = true;
            if (e.key === 'ArrowUp' && !isJumping && !gameOver) { velocityY = jumpPower; isJumping = true; }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = false;
            if (e.key === 'ArrowRight') keys.Right = false;
        });

        function explode(x, y, z) {
            const rows = 4;
            const size = 1.0 / rows;
            for(let ix=0; ix<rows; ix++) {
                for(let iy=0; iy<rows; iy++) {
                    for(let iz=0; iz<rows; iz++) {
                        const p = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00 }));
                        p.position.set(x + (ix/rows-0.5), y + (iy/rows-0.5), z + (iz/rows-0.5));
                        p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*1.2, Math.random()*0.8, (Math.random()-0.5)*1.2);
                        scene.add(p);
                        particles.push(p);
                    }
                }
            }
        }

        function spawnObstacle() {
            if (gameOver) return;
            const isLong = Math.random() < 0.4;
            const width = isLong ? 26 : 2;
            const color = isLong ? 0xffaa00 : 0xff0000;
            
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(width, 1, 1), 
                new THREE.MeshLambertMaterial({ color: color, emissive: color, emissiveIntensity: 2 })
            );
            group.add(mesh);

            // Row of lights for the Bar for a clean horizontal glow
            if(isLong) {
                const step = width / 4;
                for(let x = -width/2; x <= width/2; x += step) {
                    const l = new THREE.PointLight(color, 20, 10);
                    l.position.set(x, -0.4, 0); // Positioned near floor
                    group.add(l);
                }
            } else {
                const l = new THREE.PointLight(color, 45, 12);
                l.position.set(0, 0, 0);
                group.add(l);
            }

            group.position.set(isLong ? 0 : (Math.random()-0.5)*20, 0.5, -120);
            scene.add(group);
            obstacles.push({ mesh: group, width: width });
        }

        let spawnTimer = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                if (keys.Left && player.position.x > -20) player.position.x -= 0.25;
                if (keys.Right && player.position.x < 20) player.position.x += 0.25;
                if (isJumping) {
                    player.position.y += velocityY;
                    velocityY += gravity;
                    if (player.position.y <= 0.5) { player.position.y = 0.5; isJumping = false; }
                }
                pLight.position.copy(player.position);

                spawnTimer++;
                if (spawnTimer > 70) { spawnObstacle(); spawnTimer = 0; }

                obstacles.forEach((obj, i) => {
                    obj.mesh.position.z += speed;
                    const dx = Math.abs(player.position.x - obj.mesh.position.x);
                    const dy = Math.abs(player.position.y - obj.mesh.position.y);
                    const dz = Math.abs(player.position.z - obj.mesh.position.z);
                    if (dx < (obj.width/2 + 0.4) && dy < 0.8 && dz < 0.8) {
                        gameOver = true;
                        explode(player.position.x, player.position.y, player.position.z);
                        scene.remove(player); scene.remove(pLight);
                        audio.pause();
                        document.getElementById('msg').style.display = 'block';
                    }
                    if (obj.mesh.position.z > 20) { 
                        scene.remove(obj.mesh); obstacles.splice(i, 1); 
                        score++; document.getElementById('ui').innerText = `Score: ${score}`; 
                    }
                });
            } else {
                particles.forEach(p => {
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.multiplyScalar(friction);
                    if (p.position.y > 0.05) { 
                        p.userData.velocity.y += gravity; 
                    } else { 
                        p.position.y = 0.05; 
                        p.userData.velocity.y *= -0.5;
                        p.userData.velocity.x *= 0.7;
                        p.userData.velocity.z *= 0.7;
                    }
                });
            }
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth / PIXEL_SCALE, window.innerHeight / PIXEL_SCALE, false);
        }
        window.addEventListener('resize', onResize);
        onResize(); animate();
    </script>
</body>
</html>
