<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Runner - Sharp Friend Boss</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }
        canvas { image-rendering: pixelated; width: 100vw !important; height: 100vh !important; display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 24px; pointer-events: none; z-index: 11; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               color: white; text-align: center; display: none; background: #000; padding: 30px; border: 1px solid #f0f; z-index: 12; }
        button { background: #440044; color: #f0f; border: 1px solid #f0f; padding: 10px 20px; font-weight: bold; cursor: pointer; margin-top: 15px; }
    </style>
</head>
<body>
    <div id="crt-overlay"></div>
    <div id="ui">Score: 0</div>
    <div id="msg"><h1>CONNECTION TERMINATED</h1><button onclick="window.location.reload()">RE-LINK</button></div>

    <audio id="bgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/Air%20Waves.mp3"></audio>
    <audio id="deathSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/deltarune-explosion.mp3"></audio>
    <audio id="bossBgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/fight%20back.mp3"></audio>
    <audio id="laughSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/imagefriend.mp3"></audio>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const PIXEL_SCALE = 4;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.05));
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 2000), new THREE.MeshLambertMaterial({ color: 0x080808 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 }));
        player.position.y = 0.5;
        scene.add(player);
        const pLight = new THREE.PointLight(0x00ff00, 35, 12);
        scene.add(pLight);

        camera.position.set(0, 4, 8);
        camera.lookAt(0, 1, 0);

        // --- SHARP PIXEL TEXTURES ---
        const loader = new THREE.TextureLoader();
        function loadPixelated(url) {
            const tex = loader.load(url);
            tex.magFilter = THREE.NearestFilter; // Sharpens the 26x26 pixels
            tex.minFilter = THREE.NearestFilter;
            return tex;
        }
        const baseTex = loadPixelated('https://github.com/sand-yy/sand-yy.github.io/blob/main/base.png?raw=true');
        const laughTex = loadPixelated('https://raw.githubusercontent.com/sand-yy/sand-yy.github.io/refs/heads/main/laugh.png');

        // Audio Config
        const bgm = document.getElementById('bgm');
        const bossBgm = document.getElementById('bossBgm');
        const deathSfx = document.getElementById('deathSfx');
        deathSfx.volume = 0.5;
        bossBgm.volume = 0; // For fade-in

        let score = 0, obstacles = [], particles = [], bossProjectiles = [], speed = 0.35, gameOver = false, isJumping = false, velocityY = 0;
        let bossActive = false, bossObj = null, laughTimer = 0, bossRising = false;
        const gravity = -0.016, jumpPower = 0.3, friction = 0.96;

        const keys = { Left: false, Right: false };
        window.addEventListener('keydown', (e) => {
            if(!gameOver) bgm.play().catch(()=>{});
            if (e.key === 'ArrowLeft') keys.Left = true;
            if (e.key === 'ArrowRight') keys.Right = true;
            if (e.key === 'ArrowUp' && !isJumping && !gameOver) { velocityY = jumpPower; isJumping = true; }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = false;
            if (e.key === 'ArrowRight') keys.Right = false;
        });

        function spawnExplosion(x, y, z, color = 0x00ff00) {
            for(let i=0; i<64; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshLambertMaterial({ color: color, emissive: color }));
                p.position.set(x, y, z);
                p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*1.2, Math.random()*0.8, (Math.random()-0.5)*1.2);
                scene.add(p);
                particles.push(p);
            }
        }

        function triggerBoss(startPos) {
            bossActive = true;
            bossRising = true;
            
            // Audio Fade Logic
            let fadeOut = setInterval(() => {
                if(bgm.volume > 0.05) bgm.volume -= 0.05;
                else { bgm.pause(); clearInterval(fadeOut); }
            }, 100);

            bossBgm.play();
            let fadeIn = setInterval(() => {
                if(bossBgm.volume < 0.5) bossBgm.volume += 0.05;
                else clearInterval(fadeIn);
            }, 200);

            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles = [];

            const spriteMat = new THREE.SpriteMaterial({ map: baseTex });
            bossObj = new THREE.Sprite(spriteMat);
            bossObj.scale.set(5, 5, 1);
            bossObj.position.set(startPos.x, -2, startPos.z);
            scene.add(bossObj);
        }

        function spawnObstacle() {
            if (gameOver || bossActive) return;
            const isSpecial = Math.random() < 0.1;
            const isLong = !isSpecial && Math.random() < 0.4;
            const width = isSpecial ? 2 : (isLong ? 26 : 2);
            
            const mat = new THREE.MeshLambertMaterial({ emissiveIntensity: 2 });
            if(isSpecial) { mat.color.set(0xff00ff); mat.emissive.set(0xffff00); } 
            else { mat.color.set(isLong ? 0xffaa00 : 0xff0000); mat.emissive.set(mat.color); }

            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, 1, 1), mat);
            group.add(mesh);
            const l = new THREE.PointLight(mat.color, isSpecial?60:30, 15);
            group.add(l);
            group.position.set(isLong ? 0 : (Math.random()-0.5)*20, 0.5, -120);
            scene.add(group);
            obstacles.push({ mesh: group, width: width, special: isSpecial });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                if (keys.Left && player.position.x > -20) player.position.x -= 0.25;
                if (keys.Right && player.position.x < 20) player.position.x += 0.25;
                if (isJumping) {
                    player.position.y += velocityY; velocityY += gravity;
                    if (player.position.y <= 0.5) { player.position.y = 0.5; isJumping = false; }
                }
                pLight.position.copy(player.position);

                if(!bossActive) {
                    spawnTimer++;
                    if (spawnTimer > 70) { spawnObstacle(); spawnTimer = 0; }
                } else if(bossObj) {
                    if(bossRising) {
                        bossObj.position.y += 0.1;
                        bossObj.position.z += speed;
                        if(bossObj.position.y >= 5) bossRising = false;
                    } else {
                        // Boss Flight Path
                        bossObj.position.z = player.position.z - 18;
                        bossObj.position.x = Math.sin(Date.now() * 0.002) * 14;
                        bossObj.position.y = 5 + Math.cos(Date.now() * 0.005) * 2;
                        
                        laughTimer++;
                        if(laughTimer > 110) {
                            bossObj.material.map = laughTex;
                            document.getElementById('laughSfx').play();
                            
                            // Pink and Yellow Bullets (Slower)
                            [0xff00ff, 0xffff00].forEach((col, idx) => {
                                const proj = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshLambertMaterial({color: col, emissive: col}));
                                proj.position.copy(bossObj.position);
                                proj.position.x += (idx - 0.5) * 2;
                                const dir = new THREE.Vector3().subVectors(player.position, proj.position).normalize();
                                proj.userData.velocity = dir.multiplyScalar(0.35); // Not too fast
                                scene.add(proj);
                                bossProjectiles.push(proj);
                            });

                            // Boss Bar Attack
                            const barCol = Math.random() > 0.5 ? 0xff00ff : 0xffff00;
                            const group = new THREE.Group();
                            group.add(new THREE.Mesh(new THREE.BoxGeometry(26, 1, 1), new THREE.MeshLambertMaterial({color: barCol, emissive: barCol, emissiveIntensity: 2})));
                            group.add(new THREE.PointLight(barCol, 40, 15));
                            group.position.set(0, 0.5, bossObj.position.z - 25);
                            scene.add(group);
                            obstacles.push({ mesh: group, width: 26, special: false });

                            setTimeout(() => { if(bossObj) bossObj.material.map = baseTex; }, 900);
                            laughTimer = 0;
                        }
                    }
                }

                // Collisions
                obstacles.forEach((obj, i) => {
                    obj.mesh.position.z += (bossActive ? speed * 1.6 : speed);
                    const halfW = obj.width / 2;
                    if (player.position.x > obj.mesh.position.x - halfW - 0.4 && player.position.x < obj.mesh.position.x + halfW + 0.4 &&
                        player.position.y < obj.mesh.position.y + 0.8 &&
                        player.position.z > obj.mesh.position.z - 0.8 && player.position.z < obj.mesh.position.z + 0.8) {
                        if(obj.special) { scene.remove(obj.mesh); obstacles.splice(i, 1); triggerBoss(obj.mesh.position); }
                        else endGame();
                    }
                    if (obj.mesh.position.z > 20) { scene.remove(obj.mesh); obstacles.splice(i,1); score++; document.getElementById('ui').innerText = `Score: ${score}`; }
                });

                bossProjectiles.forEach((p, i) => {
                    p.position.add(p.userData.velocity);
                    if(player.position.distanceTo(p.position) < 0.9) endGame();
                    if(p.position.z > 20 || p.position.y < -5) { scene.remove(p); bossProjectiles.splice(i, 1); }
                });

            } else {
                particles.forEach(p => {
                    p.position.add(p.userData.velocity); p.userData.velocity.multiplyScalar(friction);
                    if (p.position.y > 0.05) p.userData.velocity.y += gravity;
                    else { p.position.y = 0.05; p.userData.velocity.y *= -0.5; }
                });
            }
            renderer.render(scene, camera);
        }

        let spawnTimer = 0;
        function endGame() {
            if(gameOver) return;
            gameOver = true;
            deathSfx.play();
            bgm.pause(); bossBgm.pause();
            spawnExplosion(player.position.x, player.position.y, player.position.z);
            scene.remove(player); scene.remove(pLight);
            document.getElementById('msg').style.display = 'block';
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth/PIXEL_SCALE, window.innerHeight/PIXEL_SCALE, false);
        }
        window.addEventListener('resize', onResize);
        onResize(); animate();
    </script>
</body>
</html>
