<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Runner - Fixed Hitboxes</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }
        canvas { image-rendering: pixelated; width: 100vw !important; height: 100vh !important; display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 24px; pointer-events: none; z-index: 11; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               color: white; text-align: center; display: none; background: #000; padding: 30px; border: 1px solid #f0f; z-index: 12; }
        button { background: #440044; color: #f0f; border: 1px solid #f0f; padding: 10px 20px; font-weight: bold; cursor: pointer; margin-top: 15px; }
    </style>
</head>
<body>
    <div id="crt-overlay"></div>
    <div id="ui">Score: 0</div>
    <div id="msg"><h1>CONNECTION TERMINATED</h1><button onclick="window.location.reload()">RE-LINK</button></div>

    <audio id="bgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/Air%20Waves.mp3"></audio>
    <audio id="deathSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/deltarune-explosion.mp3"></audio>
    <audio id="bossBgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/fight%20back.mp3"></audio>
    <audio id="laughSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/imagefriend.mp3"></audio>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const PIXEL_SCALE = 4;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.05));
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 2000), new THREE.MeshLambertMaterial({ color: 0x080808 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 }));
        player.position.y = 0.5;
        scene.add(player);
        const pLight = new THREE.PointLight(0x00ff00, 35, 12);
        scene.add(pLight);

        camera.position.set(0, 4, 8);
        camera.lookAt(0, 1, 0);

        const loader = new THREE.TextureLoader();
        const baseTex = loader.load('https://github.com/sand-yy/sand-yy.github.io/blob/main/base.png?raw=true');
        const laughTex = loader.load('https://raw.githubusercontent.com/sand-yy/sand-yy.github.io/refs/heads/main/laugh.png');

        let score = 0, obstacles = [], particles = [], bossProjectiles = [], speed = 0.35, gameOver = false, isJumping = false, velocityY = 0;
        let bossActive = false, bossObj = null, laughTimer = 0;
        const gravity = -0.016, jumpPower = 0.3, friction = 0.96;

        // Volume adjustment
        document.getElementById('deathSfx').volume = 0.5;

        const keys = { Left: false, Right: false };
        window.addEventListener('keydown', (e) => {
            if(!gameOver) document.getElementById('bgm').play().catch(()=>{});
            if (e.key === 'ArrowLeft') keys.Left = true;
            if (e.key === 'ArrowRight') keys.Right = true;
            if (e.key === 'ArrowUp' && !isJumping && !gameOver) { velocityY = jumpPower; isJumping = true; }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = false;
            if (e.key === 'ArrowRight') keys.Right = false;
        });

        function spawnExplosion(x, y, z, color = 0x00ff00) {
            for(let i=0; i<64; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshLambertMaterial({ color: color, emissive: color }));
                p.position.set(x, y, z);
                p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*1.2, Math.random()*0.8, (Math.random()-0.5)*1.2);
                scene.add(p);
                particles.push(p);
            }
        }

        function triggerBoss() {
            bossActive = true;
            document.getElementById('bgm').pause();
            document.getElementById('bossBgm').play();
            obstacles.forEach(o => scene.remove(o.mesh));
            obstacles = [];
            const spriteMat = new THREE.SpriteMaterial({ map: baseTex });
            bossObj = new THREE.Sprite(spriteMat);
            bossObj.scale.set(6, 6, 1);
            bossObj.position.set(0, 4, -20);
            scene.add(bossObj);
        }

        function spawnObstacle() {
            if (gameOver || bossActive) return;
            const isSpecial = Math.random() < 0.1;
            const isLong = !isSpecial && Math.random() < 0.4;
            const width = isSpecial ? 2 : (isLong ? 26 : 2);
            
            const mat = new THREE.MeshLambertMaterial({ emissiveIntensity: 2 });
            if(isSpecial) { mat.color.set(0xff00ff); mat.emissive.set(0xffff00); } 
            else { mat.color.set(isLong ? 0xffaa00 : 0xff0000); mat.emissive.set(mat.color); }

            const group = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, 1, 1), mat);
            group.add(mesh);
            const l = new THREE.PointLight(mat.color, isSpecial?60:30, 15);
            group.add(l);
            group.position.set(isLong ? 0 : (Math.random()-0.5)*20, 0.5, -120);
            scene.add(group);
            obstacles.push({ mesh: group, width: width, special: isSpecial });
        }

        let spawnTimer = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                if (keys.Left && player.position.x > -20) player.position.x -= 0.25;
                if (keys.Right && player.position.x < 20) player.position.x += 0.25;
                if (isJumping) {
                    player.position.y += velocityY; velocityY += gravity;
                    if (player.position.y <= 0.5) { player.position.y = 0.5; isJumping = false; }
                }
                pLight.position.copy(player.position);

                if(!bossActive) {
                    spawnTimer++;
                    if (spawnTimer > 70) { spawnObstacle(); spawnTimer = 0; }
                } else {
                    bossObj.position.z = player.position.z - 15;
                    bossObj.position.x = Math.sin(Date.now() * 0.002) * 10;
                    bossObj.position.y = 4 + Math.cos(Date.now() * 0.005) * 2;
                    laughTimer++;
                    if(laughTimer > 120) {
                        bossObj.material.map = laughTex;
                        document.getElementById('laughSfx').play();
                        const proj = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshLambertMaterial({color:0xff0000, emissive:0xff0000}));
                        proj.position.copy(bossObj.position);
                        const dir = new THREE.Vector3().subVectors(player.position, bossObj.position).normalize();
                        proj.userData.velocity = dir.multiplyScalar(0.5);
                        scene.add(proj);
                        bossProjectiles.push(proj);
                        setTimeout(() => { if(bossObj) bossObj.material.map = baseTex; }, 500);
                        laughTimer = 0;
                    }
                }

                // --- FIXED AABB COLLISION ---
                obstacles.forEach((obj, i) => {
                    obj.mesh.position.z += speed;
                    
                    const pX = player.position.x, pY = player.position.y, pZ = player.position.z;
                    const oX = obj.mesh.position.x, oY = obj.mesh.position.y, oZ = obj.mesh.position.z;
                    const halfW = obj.width / 2;

                    // Perfect box check: is player within the X, Y, and Z bounds of the bar?
                    if (pX > oX - halfW - 0.4 && pX < oX + halfW + 0.4 &&
                        pY < oY + 0.8 &&
                        pZ > oZ - 0.8 && pZ < oZ + 0.8) {
                        
                        if(obj.special) {
                            scene.remove(obj.mesh); obstacles.splice(i, 1); triggerBoss();
                        } else {
                            endGame();
                        }
                    }
                    if (obj.mesh.position.z > 20) { scene.remove(obj.mesh); obstacles.splice(i,1); score++; document.getElementById('ui').innerText = `Score: ${score}`; }
                });

                bossProjectiles.forEach((p, i) => {
                    p.position.add(p.userData.velocity);
                    if(player.position.distanceTo(p.position) < 1) endGame();
                    if(p.position.z > 20) { scene.remove(p); bossProjectiles.splice(i, 1); }
                });

            } else {
                particles.forEach(p => {
                    p.position.add(p.userData.velocity); p.userData.velocity.multiplyScalar(friction);
                    if (p.position.y > 0.05) p.userData.velocity.y += gravity;
                    else { p.position.y = 0.05; p.userData.velocity.y *= -0.5; }
                });
            }
            renderer.render(scene, camera);
        }

        function endGame() {
            gameOver = true;
            document.getElementById('deathSfx').play();
            document.getElementById('bgm').pause();
            document.getElementById('bossBgm').pause();
            spawnExplosion(player.position.x, player.position.y, player.position.z);
            scene.remove(player); scene.remove(pLight);
            document.getElementById('msg').style.display = 'block';
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth/PIXEL_SCALE, window.innerHeight/PIXEL_SCALE, false);
        }
        window.addEventListener('resize', onResize);
        onResize(); animate();
    </script>
</body>
</html>
