<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel Runner - Full Features</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crt-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }
        canvas { image-rendering: pixelated; width: 100vw !important; height: 100vh !important; display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 24px; z-index: 11; }
        #boss-ui { position: absolute; top: 20px; right: 20px; color: #f0f; font-size: 24px; display: none; z-index: 11; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               color: white; text-align: center; display: none; background: #000; padding: 30px; border: 1px solid #f0f; z-index: 12; }
        button { background: #440044; color: #f0f; border: 1px solid #f0f; padding: 10px 20px; font-weight: bold; cursor: pointer; margin-top: 15px; }
    </style>
</head>
<body>
    <div id="crt-overlay"></div>
    <div id="ui">Score: 0</div>
    <div id="boss-ui">BOSS HP: 1225</div>
    <div id="msg"><h1 id="status">CONNECTION TERMINATED</h1><button onclick="window.location.reload()">RE-LINK</button></div>

    <audio id="bgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/Air%20Waves.mp3"></audio>
    <audio id="deathSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/deltarune-explosion.mp3"></audio>
    <audio id="bossBgm" loop src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/fight%20back.mp3"></audio>
    <audio id="laughSfx" src="https://github.com/sand-yy/sand-yy.github.io/raw/refs/heads/main/imagefriend.mp3"></audio>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const PIXEL_SCALE = 4;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.05));
        
        // --- FLOOR & BORDERS ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(42, 2000), new THREE.MeshLambertMaterial({ color: 0x080808 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const borderGeo = new THREE.BoxGeometry(1, 2, 2000);
        const borderMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const leftBorder = new THREE.Mesh(borderGeo, borderMat);
        leftBorder.position.set(-21, 1, -900);
        const rightBorder = new THREE.Mesh(borderGeo, borderMat);
        rightBorder.position.set(21, 1, -900);
        scene.add(leftBorder, rightBorder);

        const player = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshLambertMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 }));
        player.position.y = 0.5;
        scene.add(player);
        const pLight = new THREE.PointLight(0x00ff00, 35, 12);
        scene.add(pLight);

        camera.position.set(0, 4, 8);
        camera.lookAt(0, 1, 0);

        const loader = new THREE.TextureLoader();
        function loadPixelated(url) {
            const tex = loader.load(url);
            tex.magFilter = tex.minFilter = THREE.NearestFilter;
            return tex;
        }
        const baseTex = loadPixelated('https://github.com/sand-yy/sand-yy.github.io/blob/main/base.png?raw=true');
        const laughTex = loadPixelated('https://raw.githubusercontent.com/sand-yy/sand-yy.github.io/refs/heads/main/laugh.png');

        const bgm = document.getElementById('bgm');
        const bossBgm = document.getElementById('bossBgm');
        document.getElementById('deathSfx').volume = 0.5;
        bossBgm.volume = 0;

        let score = 0, obstacles = [], particles = [], bossProjectiles = [], playerBullets = [], speed = 0.35;
        let gameOver = false, isJumping = false, velocityY = 0, bossActive = false, bossObj = null, laughTimer = 0, bossRising = false, bossHP = 1225;
        let warningMesh = null;
        const gravity = -0.016, jumpPower = 0.3, friction = 0.96;

        const keys = { Left: false, Right: false, Z: false };
        window.addEventListener('keydown', (e) => {
            if(!gameOver) bgm.play().catch(()=>{});
            if (e.key === 'ArrowLeft') keys.Left = true;
            if (e.key === 'ArrowRight') keys.Right = true;
            if (e.key.toLowerCase() === 'z') keys.Z = true;
            if (e.key === 'ArrowUp' && !isJumping && !gameOver) { velocityY = jumpPower; isJumping = true; }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.Left = false;
            if (e.key === 'ArrowRight') keys.Right = false;
            if (e.key.toLowerCase() === 'z') keys.Z = false;
        });

        function spawnImpactParticles(x, y, z, color) {
            for(let i=0; i<8; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.15,0.15), new THREE.MeshLambertMaterial({ color: color, emissive: color }));
                p.position.set(x, y, z);
                p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, Math.random()*0.5);
                scene.add(p);
                particles.push(p);
            }
        }

        function triggerBoss(brickPos) {
            bossActive = true; bossRising = true;
            document.getElementById('boss-ui').style.display = 'block';
            let fadeOut = setInterval(() => { if(bgm.volume > 0.05) bgm.volume -= 0.05; else { bgm.pause(); clearInterval(fadeOut); } }, 100);
            bossBgm.play();
            let fadeIn = setInterval(() => { if(bossBgm.volume < 0.5) bossBgm.volume += 0.05; else clearInterval(fadeIn); }, 200);
            bossObj = new THREE.Sprite(new THREE.SpriteMaterial({ map: baseTex }));
            bossObj.scale.set(5, 5, 1);
            bossObj.position.copy(brickPos);
            bossObj.position.y = 0.5;
            scene.add(bossObj);
            obstacles.forEach(o => { if(!o.special) scene.remove(o.mesh) });
        }

        function spawnObstacle() {
            if (gameOver || bossActive) return;
            const isSpecial = Math.random() < 0.1;
            const isLong = !isSpecial && Math.random() < 0.4;
            const width = isSpecial ? 2 : (isLong ? 26 : 2);
            const mat = new THREE.MeshLambertMaterial({ emissiveIntensity: 2 });
            const col = isSpecial ? 0xff00ff : (isLong ? 0xffaa00 : 0xff0000);
            mat.color.set(col); mat.emissive.set(isSpecial ? 0xffff00 : col);
            const group = new THREE.Group();
            group.add(new THREE.Mesh(new THREE.BoxGeometry(width, 1, 1), mat));
            group.add(new THREE.PointLight(mat.color, isSpecial?60:30, 15));
            group.position.set(isLong ? 0 : (Math.random()-0.5)*38, 0.5, -120);
            scene.add(group);
            obstacles.push({ mesh: group, width: width, special: isSpecial, color: col });
        }

        let shootCooldown = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                if (keys.Left && player.position.x > -20) player.position.x -= 0.25;
                if (keys.Right && player.position.x < 20) player.position.x += 0.25;
                if (isJumping) {
                    player.position.y += velocityY; velocityY += gravity;
                    if (player.position.y <= 0.5) { player.position.y = 0.5; isJumping = false; }
                }
                pLight.position.copy(player.position);

                if (keys.Z && shootCooldown <= 0) {
                    const b = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,1), new THREE.MeshLambertMaterial({color: 0x00ff00, emissive: 0x00ff00}));
                    b.position.copy(player.position);
                    scene.add(b); playerBullets.push(b); shootCooldown = 8;
                }
                if(shootCooldown > 0) shootCooldown--;

                if(!bossActive) { if(Date.now() % 1000 < 20) spawnObstacle(); }
                else if(bossObj) {
                    if(bossRising) {
                        bossObj.position.y += 0.05; bossObj.position.z += speed;
                        if(bossObj.position.y >= 5) bossRising = false;
                    } else {
                        bossObj.position.z = player.position.z - 20;
                        bossObj.position.x = Math.sin(Date.now() * 0.001) * 15;
                        bossObj.position.y = 5 + Math.cos(Date.now() * 0.003) * 2;
                        laughTimer++;
                        if(laughTimer === 100) {
                            warningMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 2), new THREE.MeshBasicMaterial({color: 0xff00ff, transparent: true, opacity: 0.4}));
                            warningMesh.rotation.x = -Math.PI/2;
                            warningMesh.position.set(0, 0.02, player.position.z - 30);
                            scene.add(warningMesh);
                        }
                        if(laughTimer > 180) {
                            bossObj.material.map = laughTex; document.getElementById('laughSfx').play();
                            [0xff00ff, 0xffff00].forEach((col) => {
                                const proj = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshLambertMaterial({color: col, emissive: col}));
                                proj.position.copy(bossObj.position);
                                const dir = new THREE.Vector3().subVectors(player.position, proj.position).normalize();
                                proj.userData.velocity = dir.multiplyScalar(0.25);
                                scene.add(proj); bossProjectiles.push(proj);
                            });
                            if(warningMesh) { scene.remove(warningMesh); warningMesh = null; }
                            const barCol = Math.random() > 0.5 ? 0xff00ff : 0xffff00;
                            const group = new THREE.Group();
                            group.add(new THREE.Mesh(new THREE.BoxGeometry(40, 1, 1), new THREE.MeshLambertMaterial({color: barCol, emissive: barCol, emissiveIntensity: 2})));
                            group.position.set(0, 0.5, player.position.z - 30);
                            scene.add(group); obstacles.push({ mesh: group, width: 40, special: false, color: barCol });
                            setTimeout(() => { if(bossObj) bossObj.material.map = baseTex; }, 900);
                            laughTimer = 0;
                        }
                    }
                }

                playerBullets.forEach((b, bi) => {
                    b.position.z -= 1.5;
                    // Hit Boss
                    if(bossObj && !bossRising && b.position.distanceTo(bossObj.position) < 3) {
                        bossHP--; document.getElementById('boss-ui').innerText = `BOSS HP: ${bossHP}`;
                        spawnImpactParticles(b.position.x, b.position.y, b.position.z, 0xff00ff);
                        scene.remove(b); playerBullets.splice(bi, 1);
                        if(bossHP <= 0) winGame();
                    }
                    // Hit Obstacles
                    obstacles.forEach(o => {
                        const dx = Math.abs(b.position.x - o.mesh.position.x);
                        const dz = Math.abs(b.position.z - o.mesh.position.z);
                        if(dx < o.width/2 && dz < 1) {
                            spawnImpactParticles(b.position.x, b.position.y, b.position.z, o.color);
                            scene.remove(b); playerBullets.splice(bi, 1);
                        }
                    });
                    if(b.position.z < player.position.z - 100) { scene.remove(b); playerBullets.splice(bi, 1); }
                });

                obstacles.forEach((obj, i) => {
                    if(!bossActive) obj.mesh.position.z += speed;
                    const halfW = obj.width / 2;
                    if (player.position.x > obj.mesh.position.x - halfW - 0.4 && player.position.x < obj.mesh.position.x + halfW + 0.4 &&
                        player.position.y < obj.mesh.position.y + 0.8 &&
                        player.position.z > obj.mesh.position.z - 0.8 && player.position.z < obj.mesh.position.z + 0.8) {
                        if(obj.special) triggerBoss(obj.mesh.position); else endGame();
                    }
                    if (obj.mesh.position.z > 20) { scene.remove(obj.mesh); obstacles.splice(i,1); if(!bossActive) score++; document.getElementById('ui').innerText = `Score: ${score}`; }
                });

                bossProjectiles.forEach((p, i) => {
                    p.position.add(p.userData.velocity);
                    if(player.position.distanceTo(p.position) < 0.8) endGame();
                    if(p.position.z > 20) { scene.remove(p); bossProjectiles.splice(i, 1); }
                });

            } else {
                particles.forEach((p, i) => {
                    p.position.add(p.userData.velocity); p.userData.velocity.multiplyScalar(friction);
                    if (p.position.y > 0.05) p.userData.velocity.y += gravity;
                    else { p.position.y = 0.05; p.userData.velocity.y *= -0.5; }
                    if(p.userData.velocity.length() < 0.01) { scene.remove(p); particles.splice(i, 1); }
                });
            }
            renderer.render(scene, camera);
        }

        function endGame() { if(gameOver) return; gameOver = true; document.getElementById('deathSfx').play(); bgm.pause(); bossBgm.pause(); scene.remove(player); document.getElementById('msg').style.display = 'block'; }
        function winGame() { gameOver = true; bossBgm.pause(); document.getElementById('status').innerText = "BOSS DEFEATED"; scene.remove(bossObj); document.getElementById('msg').style.display = 'block'; }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth/PIXEL_SCALE, window.innerHeight/PIXEL_SCALE, false);
        }
        window.addEventListener('resize', onResize);
        onResize(); animate();
    </script>
</body>
</html>
